PImage img;float[][] kernel = {   {     .111, .111, .111  }  , {     .111, 8, .111  }  ,   {     .111, .111, .111  }};void setup() {  img  = loadImage("streetbw.jpg"); // Load the original image  size(img.width, img.height); // size our Processing app to the image}void draw() {  img.loadPixels(); // make sure the pixels of the image are available  // create a new empty image that we'll draw into  PImage kerneledImg = createImage(width, height, RGB);  // loop through each pixel  for (int y = 1; y < height-1; y++) { // Skip top and bottom edges    for (int x = 1; x < width-1; x++) { // Skip left and right edges      float sum = 0; // Kernel sum for this pixel      // now loop through each value in the kernel      for (int kernely = -1; kernely  <= 1; kernely ++) {        for (int kernelx = -1; kernelx <= 1; kernelx++) {          // get the neighboring pixel for this value in the          // kernel matrix          int pos = (y + kernely)*width + (x + kernelx);          // Image is grayscale so red/green/blue are identical,                              //it doesn't matter          float val = red(img.pixels[pos]);          // Multiply adjacent pixels based on the kernel values          sum += kernel[kernely+1][kernelx+1] * val;        }      }      // For this pixel in the new image, set the gray value      // based on the sum from the kernel      kerneledImg.pixels[y* width + x] = color(sum);    }  }  // State that there are changes to edgeImg.pixels[]  kerneledImg.updatePixels();  image(kerneledImg, 0, 0); // Draw the new image}